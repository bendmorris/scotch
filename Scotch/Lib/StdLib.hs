module Scotch.Lib.StdLib where

import Scotch.Types.Types

stdlib = [[],[],[(Call (Var "std.lib.head") [Concat (Var "h") (Var "t")],Var "h"),(Call (Var "std.lib.head") [List []],List [])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.lib.tail") [Concat (Var "h") (Var "t")],Var "t"),(Call (Var "std.lib.tail") [List []],List [])],[(Call (Var "std.lib.left") [Concat (Var "h") (Var "t"),Var "n"],Take (Var "n") (Concat (Var "h") (Var "t"))),(Call (Var "std.lib.left") [Concat (Var "h") (Var "t"),Val (NumInt 0)],List []),(Call (Var "std.lib.left") [List [],Var "n"],List [])],[],[],[],[],[(Call (Var "std.lib.join") [Concat (Var "h") (Var "t"),Var "s"],If (ToBool (Eq (Var "t") (List []))) (Var "h") (Add (Add (Var "h") (Var "s")) (Call (Var "join") [Var "t",Var "s"]))),(Call (Var "std.lib.join") [List [],Var "s"],Val (Str "")),(Var "std.lib.reduce",Var "foldl")],[],[],[],[(Call (Var "std.lib.last") [Concat (Var "h") (Var "t")],EagerDef (Var "l") (Concat (Var "h") (Var "t")) (Subs (Sub (Call (Var "len") [Var "l"]) (Val (NumInt 1))) (Var "l")))],[(Call (Var "std.lib.prod") [Concat (Var "h") (Var "t")],Call (Var "foldr") [Val (Lambda ["x","y"] (Prod (Var "x") (Var "y"))),Concat (Var "h") (Var "t"),Val (NumInt 1)])],[],[],[],[(Call (Var "std.lib.repeat") [Var "f",Var "r",Var "n"],Call (Var "repeat") [Var "f",Call (Var "f") [Var "r"],Sub (Var "n") (Val (NumInt 1))]),(Call (Var "std.lib.repeat") [Var "f",Var "r",Val (NumInt 0)],Var "r")],[(Var "std.lib.length",Var "len")],[],[],[],[(Call (Var "std.lib.filter") [Var "f",Var "l"],For "i" (ToList (Var "l")) (Var "i") [Call (Var "f") [Var "i"]]),(Call (Var "std.lib.filter") [Var "f",List []],List [])],[],[],[(Call (Var "std.lib.show") [Var "a"],ToStr (Var "a"))],[(Call (Var "std.lib.only") [Concat (Var "h") (Var "t"),Var "s"],Add (If (ToBool (Call (Var "contains") [Var "s",Var "h"])) (Var "h") (Val (Str ""))) (Call (Var "only") [Var "t",Var "s"])),(Call (Var "std.lib.only") [List [],Var "s"],List [])],[],[],[],[(Call (Var "std.lib.prefix") [Add (Var "a") (Var "b"),Add (Var "c") (Var "d")],If (ToBool (Eq (Var "a") (Var "c"))) (Call (Var "prefix") [Var "b",Var "d"]) (Val (Bit False))),(Call (Var "std.lib.prefix") [List [],Var "c"],Val (Bit False)),(Call (Var "std.lib.prefix") [Var "a",List []],Val (Bit True))],[],[(Call (Var "std.lib.sort") [Concat (Var "h") (Var "t")],Call (Var "qsort") [Concat (Var "h") (Var "t")])],[],[],[],[],[(Call (Var "std.lib.suffix") [Var "a",Var "c"],Call (Var "prefix") [Call (Var "reverse") [Var "a"],Call (Var "reverse") [Var "c"]]),(Call (Var "std.lib.insert") [Var "x",Concat (Var "h") (Var "t"),Var "a"],If (ToBool (Gt (Var "x") (Var "h"))) (Add (Var "h") (Call (Var "insert") [Var "x",Var "t"])) (Add (Add (List [Var "x"]) (List [Var "h"])) (Var "t"))),(Call (Var "std.lib.insert") [Var "x",List [],Var "a"],Add (Var "a") (Var "x"))],[],[(Call (Var "std.lib.contains") [Concat (Var "h") (Var "t"),Var "s"],If (ToBool (Eq (Var "h") (Var "s"))) (Val (Bit True)) (Call (Var "contains") [Var "t",Var "s"])),(Call (Var "std.lib.contains") [List [],Var "s"],Val (Bit False))],[],[],[],[],[],[],[(Call (Var "std.lib.lstrip") [Concat (Var "h") (Var "t"),Var "s"],If (ToBool (Call (Var "contains") [Var "s",Var "h"])) (Call (Var "lstrip") [Var "t",Var "s"]) (Concat (Var "h") (Var "t"))),(Call (Var "std.lib.lstrip") [List [],Var "s"],List []),(Call (Var "std.lib.lstrip") [Concat (Var "h") (Var "t")],Call (Var "lstrip") [Concat (Var "h") (Var "t"),Val (Str " ")])],[(Call (Var "std.lib.insort") [Concat (Var "h") (Var "t")],Call (Var "insert") [Var "h",Call (Var "insort") [Var "t"]]),(Call (Var "std.lib.insort") [List []],List [])],[],[],[],[],[(Call (Var "std.lib.rstrip") [Var "a",Var "s"],Call (Var "reverse") [Call (Var "lstrip") [Call (Var "reverse") [Var "a"],Var "s"]]),(Call (Var "std.lib.rstrip") [Concat (Var "h") (Var "t")],Call (Var "rstrip") [Concat (Var "h") (Var "t"),Val (Str " ")])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.lib.all") [Var "l"],Call (Var "foldr") [Val (Lambda ["x","y"] (And (Var "x") (Var "y"))),Var "l",Val (Bit True)])],[],[],[],[],[(Call (Var "std.lib.map") [Var "f",Var "l"],For "i" (ToList (Var "l")) (Call (Var "f") [Var "i"]) [])],[(Call (Var "std.lib.len") [Concat (Var "h") (Var "t"),Var "a"],Call (Var "len") [Var "t",Add (Var "a") (Val (NumInt 1))]),(Call (Var "std.lib.len") [List [],Var "a"],Var "a"),(Call (Var "std.lib.len") [Var "l"],Call (Var "len") [Var "l",Val (NumInt 0)])],[],[],[],[],[],[],[],[],[(Call (Var "std.lib.any") [Var "l"],Call (Var "foldr") [Val (Lambda ["x","y"] (Or (Var "x") (Var "y"))),Var "l",Val (Bit False)])],[(Call (Var "std.lib.foldl") [Var "f",Concat (Var "h") (Var "t"),Var "z"],Call (Var "foldl") [Var "f",Var "t",Call (Var "f") [Var "z",Var "h"]]),(Call (Var "std.lib.foldl") [Var "f",List [],Var "z"],Var "z")],[],[],[(Call (Var "std.lib.replace") [Concat (Var "h") (Var "t"),Var "s",Var "r"],If (ToBool (Call (Var "prefix") [Concat (Var "h") (Var "t"),Var "s"])) (Add (Var "r") (Call (Var "replace") [Call (Var "right") [Concat (Var "h") (Var "t"),Sub (Call (Var "len") [Concat (Var "h") (Var "t")]) (Call (Var "len") [Var "s"])],Var "s",Var "r"])) (Add (Var "h") (Call (Var "replace") [Var "t",Var "s",Var "r"]))),(Call (Var "std.lib.replace") [List [],Var "s",Var "r"],List [])],[],[],[(Call (Var "std.lib.foldr") [Var "f",Concat (Var "h") (Var "t"),Var "z"],Call (Var "f") [Var "h",Call (Var "foldr") [Var "f",Var "t",Var "z"]]),(Call (Var "std.lib.foldr") [Var "f",List [],Var "z"],Var "z")],[],[],[],[(Var "std.lib.license",Val (Proc [Import ["std","license"] ["std","license"]])),(Var "std.lib.about",Val (Proc [Import ["std","about"] ["std","about"]])),(Call (Var "std.lib.zip") [Concat (Var "a") (Var "b"),Concat (Var "c") (Var "d")],Add (List [List [Var "a",Var "c"]]) (Call (Var "zip") [Var "b",Var "d"])),(Call (Var "std.lib.zip") [List [],List []],List []),(Call (Var "std.lib.zip") [List [],Concat (Var "c") (Var "d")],List []),(Call (Var "std.lib.zip") [Concat (Var "a") (Var "b"),List []],List []),(Call (Var "std.lib.zip") [Concat (Var "a") (Var "b"),Concat (Var "c") (Var "d"),Var "f"],Add (List [Call (Var "f") [Var "a",Var "c"]]) (Call (Var "zip") [Var "b",Var "d",Var "f"])),(Call (Var "std.lib.zip") [List [],List [],Var "f"],List []),(Call (Var "std.lib.zip") [List [],Concat (Var "c") (Var "d"),Var "f"],List []),(Call (Var "std.lib.zip") [Concat (Var "a") (Var "b"),List [],Var "f"],List [])],[],[(Call (Var "std.lib.sum") [Concat (Var "h") (Var "t"),Var "s"],Call (Var "foldr") [Val (Lambda ["x","y"] (Add (Var "x") (Var "y"))),Concat (Var "h") (Var "t"),Var "s"]),(Call (Var "std.lib.sum") [Var "l"],Call (Var "sum") [Var "l",Val (NumInt 0)])],[(Call (Var "std.lib.infix") [Add (Var "a") (Var "b"),Add (Var "c") (Var "d")],If (ToBool (Call (Var "prefix") [Add (Var "a") (Var "b"),Add (Var "c") (Var "d")])) (Val (Bit True)) (Call (Var "prefix") [Var "b",Add (Var "c") (Var "d")])),(Call (Var "std.lib.infix") [List [],Add (Var "c") (Var "d")],Val (Bit False)),(Call (Var "std.lib.right") [Concat (Var "h") (Var "t"),Var "n"],EagerDef (Var "l") (Call (Var "len") [Concat (Var "h") (Var "t")]) (For "i" (ToList (Range (Sub (Var "l") (Var "n")) (Sub (Var "l") (Val (NumInt 1))) (Val (NumInt 1)))) (Subs (Var "i") (Concat (Var "h") (Var "t"))) []))],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.lib.count") [Concat (Var "h") (Var "t"),Var "s",Var "a"],Call (Var "count") [Var "t",Var "s",Add (Var "a") (If (ToBool (Call (Var "prefix") [Concat (Var "h") (Var "t"),Var "s"])) (Val (NumInt 1)) (Val (NumInt 0)))]),(Call (Var "std.lib.count") [List [],Var "s",Var "a"],Var "a"),(Call (Var "std.lib.count") [Var "l",Var "s"],Call (Var "count") [Var "l",Var "s",Val (NumInt 0)])],[],[(Call (Var "std.lib.execute") [Concat (Var "h") (Var "t")],EagerDef (Var "s") (ToStr (Concat (Var "h") (Var "t"))) (EagerDef (Var "l") (Call (Var "len") [Var "s"]) (EvalExpr (Call (Var "right") [Call (Var "left") [Var "s",Sub (Var "l") (Val (NumInt 1))],Sub (Var "l") (Val (NumInt 2))])))),(Call (Var "std.lib.execute") [List []],Skip)],[(Call (Var "std.lib.split") [Concat (Var "h") (Var "t"),Var "s"],If (ToBool (Eq (Var "h") (Var "s"))) (Add (Val (Str "")) (Var "rest")) (EagerDef (Var "rest") (Call (Var "split") [Var "t",Var "s"]) (Add (List [Add (Var "h") (Call (Var "head") [Var "rest"])]) (Call (Var "tail") [Var "rest"])))),(Call (Var "std.lib.split") [List [],Var "s"],Val (Str ""))],[],[],[],[],[],[(Call (Var "std.lib.strip") [Concat (Var "h") (Var "t")],Call (Var "strip") [Concat (Var "h") (Var "t"),Val (Str " ")]),(Call (Var "std.lib.strip") [Concat (Var "h") (Var "t"),Var "s"],Call (Var "rstrip") [Call (Var "lstrip") [Concat (Var "h") (Var "t"),Var "s"],Var "s"])],[],[(Call (Var "std.lib.reverse") [Concat (Var "h") (Var "t")],For "i" (ToList (Range (Sub (Call (Var "len") [Concat (Var "h") (Var "t")]) (Val (NumInt 1))) (Val (NumInt 0)) (Prod (Val (NumInt (-1))) (Val (NumInt 1))))) (Subs (Var "i") (Concat (Var "h") (Var "t"))) [])],[],[],[],[],[(Call (Var "std.lib.qsort") [Concat (Var "h") (Var "t"),Var "n"],Case (Lt (Call (Var "len") [Concat (Var "h") (Var "t")]) (Var "n")) [(Val (Bit True),Concat (Var "h") (Var "t")),(Val (Bit False),Def (Var "less") (Call (Var "filter") [Val (Lambda ["x"] (Gt (Var "h") (Var "x"))),Var "t"]) (Def (Var "more") (Call (Var "filter") [Val (Lambda ["x"] (Lt (Var "h") (Var "x"))),Var "t"]) (Concat (Concat (Call (Var "qsort") [Var "less"]) (Var "h")) (Call (Var "qsort") [Var "more"]))))]),(Call (Var "std.lib.qsort") [List [],Var "n"],List []),(Call (Var "std.lib.qsort") [Var "l"],Call (Var "qsort") [Var "l",Val (NumInt 1)])],[],[],[],[],[(Var "std.lib.version",Val (Proc [Import ["std","version"] ["std","version"]]))],[],[],[],[],[],[],[],[],[],[],[(Var "std.lib.copyright",Val (Proc [Import ["std","copyright"] ["std","copyright"]]))],[],[(Var "std.lib.startup",Val (Proc [Import ["std","startup"] ["std","startup"]]))],[],[],[],[],[],[],[],[],[],[],[],[]]
stdabout = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
stdcopyright = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
stddecimal = [[(ToFloat (Call (Var "Decimal") [Var "a",Var "b"]),Prod (Var "a") (Exp (Val (NumInt 10)) (Prod (Val (NumInt (-1))) (Var "b"))))],[(Add (Call (Var "Decimal") [Var "a",Var "b"]) (Call (Var "Decimal") [Var "c",Var "d"]),If (ToBool (Eq (Var "b") (Var "d"))) (Call (Var "Decimal") [Add (Var "a") (Var "c"),Var "b"]) (If (ToBool (Lt (Var "b") (Var "d"))) (Add (Call (Var "Decimal") [Prod (Var "a") (Val (NumInt 10)),Add (Var "b") (Val (NumInt 1))]) (Call (Var "Decimal") [Var "c",Var "d"])) (Add (Call (Var "Decimal") [Var "a",Var "b"]) (Call (Var "Decimal") [Prod (Var "c") (Val (NumInt 10)),Add (Var "d") (Val (NumInt 1))]))))],[(Sub (Call (Var "Decimal") [Var "a",Var "b"]) (Call (Var "Decimal") [Var "c",Var "d"]),If (ToBool (Eq (Var "b") (Var "d"))) (Call (Var "Decimal") [Sub (Var "a") (Var "c"),Var "b"]) (If (ToBool (Lt (Var "b") (Var "d"))) (Sub (Call (Var "Decimal") [Prod (Var "a") (Val (NumInt 10)),Add (Var "b") (Val (NumInt 1))]) (Call (Var "Decimal") [Var "c",Var "d"])) (Sub (Call (Var "Decimal") [Var "a",Var "b"]) (Call (Var "Decimal") [Prod (Var "c") (Val (NumInt 10)),Add (Var "d") (Val (NumInt 1))]))))],[(Prod (Call (Var "Decimal") [Var "a",Var "b"]) (Call (Var "Decimal") [Var "c",Var "d"]),Call (Var "Decimal") [Prod (Var "a") (Var "c"),Add (Var "b") (Var "d")])],[(Div (Call (Var "Decimal") [Var "a",Var "b"]) (Call (Var "Decimal") [Var "c",Var "d"]),Call (Var "decimal") [ToStr (Prod (Div (ToFloat (Var "a")) (Var "c")) (Div (ToFloat (Exp (Val (NumInt 10)) (Var "d"))) (Exp (Val (NumInt 10)) (Var "b"))))])],[],[],[(Eq (Call (Var "Decimal") [Var "a",Var "b"]) (Call (Var "Decimal") [Var "c",Var "d"]),If (ToBool (Eq (Var "b") (Var "d"))) (Eq (Var "a") (Var "c")) (If (ToBool (Lt (Var "b") (Var "d"))) (Eq (Call (Var "Decimal") [Prod (Var "a") (Val (NumInt 10)),Add (Var "b") (Val (NumInt 1))]) (Call (Var "Decimal") [Var "c",Var "d"])) (Eq (Call (Var "Decimal") [Var "a",Var "b"]) (Call (Var "Decimal") [Prod (Var "c") (Val (NumInt 10)),Add (Var "d") (Val (NumInt 1))]))))],[],[],[],[],[],[],[],[(Output (Call (Var "Decimal") [Var "a",Var "b"]),Output (Add (Add (If (ToBool (Gt (Var "l") (Var "b"))) (Call (Var "left") [Var "s",Sub (Var "l") (Var "b")]) (Val (Str "0"))) (Val (Str "."))) (Case (Add (Prod (Val (Str "0")) (Sub (Var "b") (Var "l"))) (Call (Var "right") [Var "s",Var "b"])) [(Val (Str ""),Val (Str "0")),(Var "otherwise",Def (Var "s") (ToStr (Var "a")) (EagerDef (Var "l") (Call (Var "len") [Var "s"]) (Var "otherwise")))])))],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.decimal.read_decimal") [Concat (Var "h") (Var "t"),Var "a"],Case (Var "h") [(Val (Str "."),Call (Var "Decimal") [ToInt (Add (Var "a") (Var "t")),Call (Var "len") [Var "t"]]),(Var "otherwise",Call (Var "read_decimal") [Var "t",Add (Var "a") (Var "h")])]),(Call (Var "std.decimal.read_decimal") [List [],Var "a"],Call (Var "Decimal") [ToInt (Var "a"),Val (NumInt 0)])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.decimal.decimal") [Var "s"],Call (Var "read_decimal") [Var "s",Val (Str "0")])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
stdfraction = [[(ToFloat (Call (Var "Fraction") [Var "a",Var "b"]),Div (ToFloat (Var "a")) (Var "b"))],[(Add (Call (Var "Fraction") [Var "a",Var "b"]) (Call (Var "Fraction") [Var "c",Var "d"]),If (ToBool (Eq (Var "b") (Var "d"))) (Call (Var "reduce_fraction") [Call (Var "Fraction") [Add (Var "a") (Var "c"),Var "b"]]) (Add (Call (Var "Fraction") [Prod (Var "a") (Var "d"),Prod (Var "b") (Var "d")]) (Call (Var "Fraction") [Prod (Var "c") (Var "b"),Prod (Var "d") (Var "b")])))],[(Sub (Call (Var "Fraction") [Var "a",Var "b"]) (Call (Var "Fraction") [Var "c",Var "d"]),If (ToBool (Eq (Var "b") (Var "d"))) (Call (Var "reduce_fraction") [Call (Var "Fraction") [Sub (Var "a") (Var "c"),Var "b"]]) (Sub (Call (Var "Fraction") [Prod (Var "a") (Var "d"),Prod (Var "b") (Var "d")]) (Call (Var "Fraction") [Prod (Var "c") (Var "b"),Prod (Var "d") (Var "b")])))],[(Prod (Call (Var "Fraction") [Var "a",Var "b"]) (Call (Var "Fraction") [Var "c",Var "d"]),Call (Var "reduce_fraction") [Call (Var "Fraction") [Prod (Var "a") (Var "c"),Prod (Var "b") (Var "d")]])],[(Div (Call (Var "Fraction") [Var "a",Var "b"]) (Call (Var "Fraction") [Var "c",Var "d"]),Call (Var "reduce_fraction") [Prod (Call (Var "Fraction") [Var "a",Var "b"]) (Call (Var "Fraction") [Var "d",Var "c"])])],[],[],[(Eq (Call (Var "Fraction") [Var "a",Var "b"]) (Call (Var "Fraction") [Var "c",Var "d"]),EagerDef (Var "f1") (Call (Var "reduce_fraction") [Call (Var "Fraction") [Var "a",Var "b"]]) (EagerDef (Var "f2") (Call (Var "reduce_fraction") [Call (Var "Fraction") [Var "c",Var "d"]]) (And (Eq (Call (Var "numerator") [Var "f1"]) (Call (Var "numerator") [Var "f2"])) (Eq (Call (Var "denominator") [Var "f1"]) (Call (Var "denominator") [Var "f2"])))))],[],[],[],[],[],[],[],[(Output (Call (Var "Fraction") [Var "a",Var "b"]),Output (Add (Add (Var "a") (Val (Str "/"))) (Var "b")))],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.fraction.fraction") [Var "s"],Call (Var "read_fraction") [Var "s",Val (Str "0")])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.fraction.read_fraction") [Concat (Var "h") (Var "t"),Var "a"],Case (Var "h") [(Val (Str "/"),Call (Var "Fraction") [ToInt (Var "a"),ToInt (Var "t")]),(Var "otherwise",Call (Var "read_fraction") [Var "t",Add (Var "a") (Var "h")])]),(Call (Var "std.fraction.read_fraction") [List [],Var "a"],Call (Var "Fraction") [ToInt (Var "a"),Val (NumInt 1)])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.fraction.reduce_fraction") [Call (Var "Fraction") [Var "a",Var "b"]],Case (Call (Var "len") [Take (Val (NumInt 1)) (Var "divisors")]) [(Val (NumInt 0),Call (Var "Fraction") [Var "a",Var "b"]),(Var "otherwise",EagerDef (Var "divisors") (For "i" (ToList (Call (Var "reverse") [Range (Val (NumInt 2)) (Var "b") (Val (NumInt 1))])) (Var "i") [Eq (Mod (Var "a") (Var "i")) (Val (NumInt 0)),Eq (Mod (Var "b") (Var "i")) (Val (NumInt 0))]) (Call (Var "reduce_fraction") [Call (Var "Fraction") [Div (Var "a") (Subs (Val (NumInt 0)) (Var "divisors")),Div (Var "b") (Subs (Val (NumInt 0)) (Var "divisors"))]]))])],[],[],[(Call (Var "std.fraction.denominator") [Call (Var "Fraction") [Var "a",Var "b"]],Var "b")],[],[],[],[],[(Call (Var "std.fraction.numerator") [Call (Var "Fraction") [Var "a",Var "b"]],Var "a")],[],[],[],[],[],[],[],[],[],[]]
stdlicense = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
stdunit = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.unit.assert_equal") [Var "a",Var "b"],If (ToBool (Eq (Var "a") (Var "b"))) (List [List [Var "n",Val (Str "pass")]]) (EagerDef (Var "n") (Add (Call (Var "len") [Var "tests"]) (Val (NumInt 1))) (List [List [Var "n",Add (Add (ToStr (Var "a")) (Val (Str " != "))) (ToStr (Var "b"))]])))],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Var "std.unit.tests",List [])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.unit.run_tests") [Var "tests"],Val (Proc [Output (If (ToBool (Eq (For "test" (ToList (Var "tests")) (Subs (Val (NumInt 1)) (Var "test")) []) (Prod (List [Val (Str "pass")]) (Call (Var "len") [Var "tests"])))) (Add (Add (Val (Str "All ")) (ToStr (Call (Var "len") [Var "tests"]))) (Val (Str " tests passed."))) (Add (Call (Var "show") [For "test" (ToList (Var "tests")) (Var "test") [InEq (Subs (Val (NumInt 1)) (Var "test")) (Val (Str "pass"))]]) (Val (Str "\nSome tests failed.")))),Output (Val (Str "Done!"))]))]]
stdunits = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.units.to_centi") [Var "n"],Call (Var "Centi") [Prod (Var "n") (Val (NumInt 100))]),(Call (Var "std.units.to_hecto") [Var "n"],Call (Var "Hecto") [Div (Var "n") (Val (NumFloat 100.0))])],[],[],[],[(Call (Var "std.units.to_milli") [Var "n"],Call (Var "Milli") [Prod (Var "n") (Val (NumInt 1000))])],[],[],[(Call (Var "std.units.to_micro") [Var "n"],Call (Var "Micro") [Prod (Var "n") (Val (NumInt 1000000))])],[(Call (Var "std.units.to_femto") [Var "n"],Call (Var "Femto") [Prod (Var "n") (Val (NumInt 1000000000000000))])],[(Call (Var "std.units.from_centi") [Call (Var "Centi") [Var "n"]],Div (Var "n") (Val (NumFloat 100.0))),(Call (Var "std.units.from_hecto") [Call (Var "Hecto") [Var "n"]],Prod (Var "n") (Val (NumFloat 100.0)))],[],[],[],[(Call (Var "std.units.from_milli") [Call (Var "Milli") [Var "n"]],Div (Var "n") (Val (NumFloat 1000.0)))],[],[],[(Call (Var "std.units.from_micro") [Call (Var "Micro") [Var "n"]],Div (Var "n") (Val (NumFloat 1000000.0)))],[(Call (Var "std.units.from_femto") [Call (Var "Femto") [Var "n"]],Div (Var "n") (Val (NumFloat 1.0e15)))],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.units.convert_unit") [Var "n",Var "to"],Call (Var "to") [Call (Var "from_func") [Var "n"]])],[],[],[],[],[],[],[(Call (Var "std.units.to_deca") [Var "n"],Call (Var "Deca") [Div (Var "n") (Val (NumFloat 10.0))])],[],[],[],[],[],[],[],[(Call (Var "std.units.to_deci") [Var "n"],Call (Var "Deci") [Prod (Var "n") (Val (NumInt 10))])],[(Call (Var "std.units.from_deca") [Call (Var "Deca") [Var "n"]],Prod (Var "n") (Val (NumFloat 10.0)))],[],[(Call (Var "std.units.to_giga") [Var "n"],Call (Var "Giga") [Div (Var "n") (Val (NumFloat 1.0e9))])],[],[(Call (Var "std.units.to_mega") [Var "n"],Call (Var "Mega") [Div (Var "n") (Val (NumFloat 1000000.0))])],[],[],[],[(Call (Var "std.units.from_deci") [Call (Var "Deci") [Var "n"]],Div (Var "n") (Val (NumFloat 10.0)))],[],[],[(Call (Var "std.units.from_giga") [Call (Var "Giga") [Var "n"]],Prod (Var "n") (Val (NumFloat 1.0e9)))],[],[(Call (Var "std.units.from_mega") [Call (Var "Mega") [Var "n"]],Prod (Var "n") (Val (NumFloat 1000000.0)))],[],[],[],[],[],[],[(Call (Var "std.units.to_peta") [Var "n"],Call (Var "Peta") [Div (Var "n") (Val (NumFloat 1.0e15))])],[(Call (Var "std.units.to_pico") [Var "n"],Call (Var "Pico") [Prod (Var "n") (Val (NumInt 1000000000000))])],[(Call (Var "std.units.to_nano") [Var "n"],Call (Var "Nano") [Prod (Var "n") (Val (NumInt 1000000000))]),(Call (Var "std.units.to_tera") [Var "n"],Call (Var "Tera") [Div (Var "n") (Val (NumFloat 1.0e12))])],[],[],[(Call (Var "std.units.to_kilo") [Var "n"],Call (Var "Kilo") [Div (Var "n") (Val (NumFloat 1000.0))])],[],[],[],[(Call (Var "std.units.from_peta") [Call (Var "Peta") [Var "n"]],Prod (Var "n") (Val (NumFloat 1.0e15)))],[(Call (Var "std.units.from_pico") [Call (Var "Pico") [Var "n"]],Div (Var "n") (Val (NumFloat 1.0e12)))],[(Call (Var "std.units.from_nano") [Call (Var "Nano") [Var "n"]],Div (Var "n") (Val (NumFloat 1.0e9))),(Call (Var "std.units.from_tera") [Call (Var "Tera") [Var "n"]],Prod (Var "n") (Val (NumFloat 1.0e12))),(Call (Var "std.units.from_func") [Call (Var "Femto") [Var "n"]],Call (Var "from_femto") [Call (Var "Femto") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Pico") [Var "n"]],Call (Var "from_pico") [Call (Var "Pico") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Nano") [Var "n"]],Call (Var "from_nano") [Call (Var "Nano") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Micro") [Var "n"]],Call (Var "from_micro") [Call (Var "Micro") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Milli") [Var "n"]],Call (Var "from_milli") [Call (Var "Milli") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Centi") [Var "n"]],Call (Var "from_centi") [Call (Var "Centi") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Deci") [Var "n"]],Call (Var "from_deci") [Call (Var "Deci") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Deca") [Var "n"]],Call (Var "from_deca") [Call (Var "Deca") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Hecto") [Var "n"]],Call (Var "from_hecto") [Call (Var "Hecto") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Kilo") [Var "n"]],Call (Var "from_kilo") [Call (Var "Kilo") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Mega") [Var "n"]],Call (Var "from_mega") [Call (Var "Mega") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Giga") [Var "n"]],Call (Var "from_giga") [Call (Var "Giga") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Tera") [Var "n"]],Call (Var "from_tera") [Call (Var "Tera") [Var "n"]]),(Call (Var "std.units.from_func") [Call (Var "Peta") [Var "n"]],Call (Var "from_peta") [Call (Var "Peta") [Var "n"]])],[],[],[(Call (Var "std.units.from_kilo") [Call (Var "Kilo") [Var "n"]],Prod (Var "n") (Val (NumFloat 1000.0)))],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
stdversion = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
stdmath = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.math.fact") [Var "n"],Call (Var "fact") [Var "n",Val (NumInt 1)]),(Call (Var "std.math.fact") [Var "n",Var "a"],Call (Var "fact") [Sub (Var "n") (Val (NumInt 1)),Prod (Var "n") (Var "a")]),(Call (Var "std.math.fact") [Val (NumInt 0),Var "a"],Var "a")],[],[],[(Var "std.math.pi",Val (NumFloat 3.141592654)),(Call (Var "std.math.mean") [Concat (Var "h") (Var "t")],Div (Call (Var "sum") [Concat (Var "h") (Var "t")]) (Call (Var "len") [Concat (Var "h") (Var "t")])),(Call (Var "std.math.mean") [List []],Val (NumInt 0))],[],[],[],[],[(Call (Var "std.math.median") [Concat (Var "h") (Var "t")],Call (Var "median'") [Call (Var "sort") [Concat (Var "h") (Var "t")]]),(Call (Var "std.math.median") [List []],Val (NumInt 0))],[],[],[],[(Var "std.math.odds",Call (Var "filter") [Var "odd",Range (Val (NumInt 1)) Skip (Val (NumInt 1))])],[],[],[],[(Call (Var "std.math.even") [Var "n"],Eq (Mod (Var "n") (Val (NumInt 2))) (Val (NumInt 0)))],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Var "std.math.infinite",Rule [Def (Add (Call (Var "infinity") []) (Var "x")) (Var "infinity") Skip,Def (Add (Var "x") (Call (Var "infinity") [])) (Add (Var "infinity") (Var "x")) Skip,Def (Prod (Call (Var "infinity") []) (Var "x")) (If (ToBool (Eq (Var "x") (Val (NumInt 0)))) (Val (NumInt 0)) (If (ToBool (Gt (Var "x") (Val (NumInt 0)))) (Var "infinity") (Var "neg_infinity"))) Skip,Def (Prod (Var "x") (Call (Var "infinity") [])) (Prod (Var "infinity") (Var "x")) Skip,Def (Div (Call (Var "infinity") []) (Var "x")) (Var "infinity") Skip,Def (Div (Var "x") (Call (Var "infinity") [])) (Val (NumInt 0)) Skip,Def (Sub (Call (Var "infinity") []) (Var "x")) (Var "infinity") Skip,Def (Sub (Var "x") (Call (Var "infinity") [])) (Var "neg_infinity") Skip])],[],[(Var "std.math.primes",Call (Var "filter") [Var "prime",Range (Val (NumInt 2)) Skip (Val (NumInt 1))])],[],[(Call (Var "std.math.sqrt") [Var "n"],Exp (Var "n") (Val (NumFloat 0.5)))],[],[],[(Call (Var "std.math.median'") [List []],Val (NumInt 0))],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.math.divisors") [Var "n"],For "i" (ToList (Range (Val (NumInt 1)) (Sub (Var "n") (Val (NumInt 1))) (Val (NumInt 1)))) (Var "i") [Eq (Mod (Var "n") (Var "i")) (Val (NumInt 0)),Gt (Var "n") (Val (NumInt 0))])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Var "std.math.e",Val (NumFloat 2.71828183))],[],[],[],[(Call (Var "std.math.fib") [Var "a",Var "b",Var "n"],Call (Var "fib") [Var "b",Add (Var "a") (Var "b"),Sub (Var "n") (Val (NumInt 1))]),(Call (Var "std.math.fib") [Var "a",Var "b",Val (NumInt 0)],Var "a"),(Call (Var "std.math.fib") [Var "n"],Call (Var "fib") [Val (NumInt 0),Val (NumInt 1),Var "n"])],[],[],[],[],[(Call (Var "std.math.abs") [Var "n"],If (ToBool (Lt (Var "n") (Val (NumInt 0)))) (Prod (Val (NumInt (-1))) (Var "n")) (Var "n"))],[(Call (Var "std.math.odd") [Var "n"],Not (Call (Var "even") [Var "n"]))],[],[],[],[],[],[],[(Var "std.math.algebra",Rule [Def (Exp (Add (Var "x") (Var "y")) (Var "n")) (If (ToBool (Gt (Var "n") (Val (NumInt 2)))) (Prod (Exp (Add (Var "x") (Var "y")) (Val (NumInt 2))) (Exp (Add (Var "x") (Var "y")) (Sub (Var "n") (Val (NumInt 2))))) (Exp (Add (Var "x") (Var "y")) (Var "n"))) Skip,Def (Exp (Add (Var "x") (Var "y")) (Val (NumInt 2))) (Add (Add (Exp (Var "x") (Val (NumInt 2))) (Call (Prod (Val (NumInt 2)) (Var "x")) [Var "y"])) (Exp (Var "y") (Val (NumInt 2)))) Skip])],[],[],[],[(Call (Var "std.math.divisors'") [Var "n"],For "i" (ToList (Concat (Val (NumInt 2)) (Range (Val (NumInt 3)) (ToInt (Add (Call (Var "sqrt") [Var "n"]) (Val (NumInt 2)))) (Val (NumInt 2))))) (Var "i") [Eq (Mod (Var "n") (Var "i")) (Val (NumInt 0)),Gt (Var "n") (Val (NumInt 2))])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.math.deriv") [Var "a"],Val (NumInt 0)),(Call (Var "std.math.deriv") [Add (Var "a") (Var "b")],Add (Call (Var "deriv") [Var "a"]) (Call (Var "deriv") [Var "b"])),(Call (Var "std.math.deriv") [Sub (Var "a") (Var "b")],Sub (Call (Var "deriv") [Var "a"]) (Call (Var "deriv") [Var "b"])),(Call (Var "std.math.deriv") [Exp (Var "x") (Var "n")],Prod (Var "n") (Exp (Var "x") (Sub (Var "n") (Val (NumInt 1))))),(Call (Var "std.math.deriv") [Prod (Var "a") (Exp (Var "x") (Var "n"))],Prod (Var "a") (Call (Var "deriv") [Exp (Var "x") (Var "n")])),(Call (Var "std.math.deriv") [Prod (Var "a") (Call (Var "x") [])],Var "a"),(Call (Var "std.math.deriv") [Call (Var "x") []],Val (NumInt 1)),(Call (Var "std.math.deriv") [Call (Var "sin") [Var "x"]],Prod (Call (Var "cos") [Var "x"]) (Call (Var "deriv") [Var "x"])),(Call (Var "std.math.deriv") [Call (Var "cos") [Var "x"]],Prod (Call (Prod (Val (NumInt (-1))) (Var "sin")) [Var "x"]) (Call (Var "deriv") [Var "x"])),(Call (Var "std.math.deriv") [Exp (Call (Var "e") []) (Call (Var "x") [])],Exp (Var "e") (Var "x")),(Call (Var "std.math.deriv") [Exp (Call (Var "e") []) (Prod (Var "a") (Call (Var "x") []))],Prod (Call (Var "deriv") [Prod (Var "a") (Var "x")]) (Exp (Var "e") (Prod (Var "a") (Var "x")))),(Call (Var "std.math.deriv") [Call (Var "ln") [Var "x"]],Div (Val (NumInt 1)) (Var "x"))],[],[],[(Call (Var "std.math.prime") [Var "n"],If (ToBool (Lt (Var "n") (Val (NumInt 2)))) (Val (Bit False)) (Eq (Call (Var "len") [Take (Val (NumInt 1)) (Call (Var "divisors'") [Var "n"])]) (Val (NumInt 0))))],[],[],[],[(Var "std.math.evens",Call (Var "filter") [Var "even",Range (Val (NumInt 2)) Skip (Val (NumInt 1))])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
stdmathalgebra = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Var "std.math.algebra.algebra",Rule [Def (Exp (Add (Var "x") (Var "y")) (Var "n")) (If (ToBool (Gt (Var "n") (Val (NumInt 2)))) (Prod (Exp (Add (Var "x") (Var "y")) (Val (NumInt 2))) (Exp (Add (Var "x") (Var "y")) (Sub (Var "n") (Val (NumInt 2))))) (Exp (Add (Var "x") (Var "y")) (Var "n"))) Skip,Def (Exp (Add (Var "x") (Var "y")) (Val (NumInt 2))) (Add (Add (Exp (Var "x") (Val (NumInt 2))) (Call (Prod (Val (NumInt 2)) (Var "x")) [Var "y"])) (Exp (Var "y") (Val (NumInt 2)))) Skip])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
stdmathcalculus = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Call (Var "std.math.calculus.deriv") [Var "a"],Val (NumInt 0)),(Call (Var "std.math.calculus.deriv") [Add (Var "a") (Var "b")],Add (Call (Var "deriv") [Var "a"]) (Call (Var "deriv") [Var "b"])),(Call (Var "std.math.calculus.deriv") [Sub (Var "a") (Var "b")],Sub (Call (Var "deriv") [Var "a"]) (Call (Var "deriv") [Var "b"])),(Call (Var "std.math.calculus.deriv") [Exp (Var "x") (Var "n")],Prod (Var "n") (Exp (Var "x") (Sub (Var "n") (Val (NumInt 1))))),(Call (Var "std.math.calculus.deriv") [Prod (Var "a") (Exp (Var "x") (Var "n"))],Prod (Var "a") (Call (Var "deriv") [Exp (Var "x") (Var "n")])),(Call (Var "std.math.calculus.deriv") [Prod (Var "a") (Call (Var "x") [])],Var "a"),(Call (Var "std.math.calculus.deriv") [Call (Var "x") []],Val (NumInt 1)),(Call (Var "std.math.calculus.deriv") [Call (Var "sin") [Var "x"]],Prod (Call (Var "cos") [Var "x"]) (Call (Var "deriv") [Var "x"])),(Call (Var "std.math.calculus.deriv") [Call (Var "cos") [Var "x"]],Prod (Call (Prod (Val (NumInt (-1))) (Var "sin")) [Var "x"]) (Call (Var "deriv") [Var "x"])),(Call (Var "std.math.calculus.deriv") [Exp (Call (Var "e") []) (Call (Var "x") [])],Exp (Var "e") (Var "x")),(Call (Var "std.math.calculus.deriv") [Exp (Call (Var "e") []) (Prod (Var "a") (Call (Var "x") []))],Prod (Call (Var "deriv") [Prod (Var "a") (Var "x")]) (Exp (Var "e") (Prod (Var "a") (Var "x")))),(Call (Var "std.math.calculus.deriv") [Call (Var "ln") [Var "x"]],Div (Val (NumInt 1)) (Var "x"))],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
stdmathinfinity = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[(Var "std.math.infinity.infinite",Rule [Def (Add (Call (Var "infinity") []) (Var "x")) (Var "infinity") Skip,Def (Add (Var "x") (Call (Var "infinity") [])) (Add (Var "infinity") (Var "x")) Skip,Def (Prod (Call (Var "infinity") []) (Var "x")) (If (ToBool (Eq (Var "x") (Val (NumInt 0)))) (Val (NumInt 0)) (If (ToBool (Gt (Var "x") (Val (NumInt 0)))) (Var "infinity") (Var "neg_infinity"))) Skip,Def (Prod (Var "x") (Call (Var "infinity") [])) (Prod (Var "infinity") (Var "x")) Skip,Def (Div (Call (Var "infinity") []) (Var "x")) (Var "infinity") Skip,Def (Div (Var "x") (Call (Var "infinity") [])) (Val (NumInt 0)) Skip,Def (Sub (Call (Var "infinity") []) (Var "x")) (Var "infinity") Skip,Def (Sub (Var "x") (Call (Var "infinity") [])) (Var "neg_infinity") Skip])],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]